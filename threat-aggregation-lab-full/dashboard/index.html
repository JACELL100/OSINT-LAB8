<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Threat Feed Dashboard</title>
<style>
  :root{
    --bg:#0f1724; --card:#0b1220; --muted:#9aa7bf; --accent:#60a5fa; --success:#34d399;
    --panel-padding:16px; --radius:12px; --glass: rgba(255,255,255,0.02);
  }
  html,body{height:100%;margin:0;font-family:Inter,ui-sans-serif,system-ui,Segoe UI,Roboto,"Helvetica Neue",Arial;color:#e6eef8;background:linear-gradient(180deg,#071023 0%, #071733 100%);-webkit-font-smoothing:antialiased}
  .wrap{max-width:1200px;margin:28px auto;padding:20px}
  header{display:flex;align-items:center;gap:16px;margin-bottom:18px}
  h1{margin:0;font-size:20px}
  .sub{color:var(--muted);font-size:13px}
  .controls{display:flex;gap:12px;align-items:center;margin-bottom:16px}
  .drop{
    flex:1;min-height:84px;border:2px dashed rgba(255,255,255,0.06);background:var(--glass);
    border-radius:var(--radius);padding:14px;display:flex;flex-direction:column;justify-content:center;align-items:center;gap:6px;color:var(--muted)
  }
  input[type=file]{display:none}
  .btn{background:linear-gradient(90deg,var(--accent),#3b82f6);border:none;color:white;padding:10px 14px;border-radius:10px;cursor:pointer;font-weight:600}
  .grid{display:grid;grid-template-columns:repeat(12,1fr);gap:14px}
  .card{grid-column:span 4;background:linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));padding:var(--panel-padding);border-radius:10px;min-height:110px;box-shadow:0 6px 20px rgba(2,6,23,0.6)}
  .wide{grid-column:span 8}
  .full{grid-column:span 12}
  .stat{font-size:20px;font-weight:700}
  .label{color:var(--muted);font-size:13px;margin-top:6px}
  .chart{margin-top:10px;height:140px}
  .table-wrap{background:var(--card);padding:12px;border-radius:10px;color:#dbeafe;overflow:auto}
  table{width:100%;border-collapse:collapse;font-size:13px;color:#dbeafe}
  th,td{padding:8px;text-align:left;border-bottom:1px solid rgba(255,255,255,0.03)}
  th{color:var(--muted);font-weight:600;font-size:12px}
  .search{display:flex;gap:8px;align-items:center;margin-bottom:8px}
  .input{background:transparent;border:1px solid rgba(255,255,255,0.04);color:var(--muted);padding:8px;border-radius:8px;min-width:180px}
  .badge{display:inline-block;padding:4px 8px;border-radius:999px;background:rgba(255,255,255,0.03);font-size:12px}
  footer{margin-top:18px;color:var(--muted);font-size:13px}
  .small{font-size:12px;color:var(--muted)}
  /* responsive */
  @media (max-width:900px){ .grid{grid-template-columns:repeat(6,1fr)} .card{grid-column:span 6}.wide{grid-column:span 6} }
  @media (max-width:560px){ .wrap{padding:12px} header{flex-direction:column;align-items:flex-start} .controls{flex-direction:column;align-items:stretch} }
</style>
</head>
<body>
  <div class="wrap">
    <header>
      <div>
        <h1>Threat Feed Dashboard</h1>
        <div class="sub">Drag & drop your normalized <code>.stix.jsonl</code> or raw <code>.jsonl</code> files here — the dashboard parses and visualizes them.</div>
      </div>
      <div style="margin-left:auto" class="small">Records loaded: <span id="totalCount">0</span></div>
    </header>

    <div class="controls">
      <label class="drop" id="dropzone">
        <div style="font-weight:700">Drop files here or click to select</div>
        <div class="small">Supports multiple .jsonl files — normalized STIX output recommended</div>
        <input id="fileInput" type="file" multiple accept=".json,.jsonl,text/plain"/>
      </label>
      <button class="btn" id="exportBtn" title="Export merged JSONL">Export merged JSONL</button>
      <button class="btn" id="clearBtn" style="background:linear-gradient(90deg,#ef4444,#f97316)">Clear</button>
    </div>

    <div class="grid" id="dashGrid">
      <div class="card">
        <div class="label">Total records</div>
        <div class="stat" id="statTotal">0</div>
        <div class="label">Unique indicators: <span id="uniqueIndicators">0</span></div>
      </div>

      <div class="card">
        <div class="label">By source</div>
        <div id="sourceList" style="margin-top:8px"></div>
        <div class="chart" id="sourceChart"></div>
      </div>

      <div class="card">
        <div class="label">By indicator type</div>
        <div id="typeList" style="margin-top:8px"></div>
        <div class="chart" id="typeChart"></div>
      </div>

      <div class="wide card">
        <div class="label">Top indicators</div>
        <div id="topIndicators" style="margin-top:8px"></div>
      </div>

      <div class="full card">
        <div style="display:flex;justify-content:space-between;align-items:center">
          <div>
            <div class="label">Timeline by first_seen date</div>
            <div class="small" id="timelineRange"></div>
          </div>
          <div class="search">
            <input id="filterText" class="input" placeholder="Filter table (indicator / ip / source)"/>
            <select id="pageSize" class="input" title="rows per page">
              <option value="10">10 rows</option><option value="25">25 rows</option><option value="50">50 rows</option>
            </select>
          </div>
        </div>
        <div class="chart" id="timelineChart"></div>
      </div>

      <div class="full">
        <div class="table-wrap">
          <div style="display:flex;justify-content:space-between;align-items:center">
            <div class="small">Showing records (paged)</div>
            <div class="small">Page: <span id="pageIndex">1</span>/<span id="pageTotal">1</span></div>
          </div>
          <table id="recordsTable">
            <thead><tr><th>indicator</th><th>type</th><th>first_seen</th><th>last_seen</th><th>source</th><th>confidence</th></tr></thead>
            <tbody id="tableBody"></tbody>
          </table>
          <div style="margin-top:8px;display:flex;gap:8px;align-items:center">
            <button class="btn" id="prevBtn" style="background:#2b6cb0">Prev</button>
            <button class="btn" id="nextBtn" style="background:#2b6cb0">Next</button>
            <div class="small" style="margin-left:auto">Click a row to copy full JSON to clipboard</div>
          </div>
        </div>
      </div>
    </div>

    <footer>
      <div class="small">Built for local use — no data leaves your browser. Works with normalized records that include keys: <code>indicator</code>, <code>indicator_type</code>, <code>first_seen</code>, <code>last_seen</code>, <code>source</code>.</div>
    </footer>
  </div>

<script>
(() => {
  // state
  let records = []; // array of normalized objects
  let mergedRaw = []; // for export
  const totalCountEl = document.getElementById('totalCount');
  const statTotal = document.getElementById('statTotal');
  const uniqueIndicators = document.getElementById('uniqueIndicators');
  const sourceList = document.getElementById('sourceList');
  const typeList = document.getElementById('typeList');
  const topIndicators = document.getElementById('topIndicators');
  const timelineRange = document.getElementById('timelineRange');

  const sourceChart = document.getElementById('sourceChart');
  const typeChart = document.getElementById('typeChart');
  const timelineChart = document.getElementById('timelineChart');

  const tableBody = document.getElementById('tableBody');
  const pageSizeSelect = document.getElementById('pageSize');
  const filterText = document.getElementById('filterText');
  const pageIndexEl = document.getElementById('pageIndex');
  const pageTotalEl = document.getElementById('pageTotal');

  let pageIndex = 1;
  let pageSize = parseInt(pageSizeSelect.value,10);

  // helper: parse ISO date to YYYY-MM-DD
  function toDateKey(dt){
    try{
      const d = new Date(dt);
      if (isNaN(d.getTime())) return null;
      return d.toISOString().slice(0,10);
    }catch(e){ return null; }
  }

  // parse JSONL text -> records; tolerant
  function parseJSONL(text){
    const lines = text.split(/\r?\n/);
    const out = [];
    for (const line of lines){
      if (!line || !line.trim()) continue;
      try {
        const obj = JSON.parse(line);
        if (obj && typeof obj === 'object') {
          out.push(obj);
        }
      } catch(e){
        // tolerant: try to recover if it is bytes repr from orjson .decode(...)
        try {
          // often orjson writes bytes representation when saved incorrectly; skip
        } catch(_) {}
      }
    }
    return out;
  }

  // Normalizer fallback: try to produce required fields if missing
  function ensureNormalized(obj){
    const now = (new Date()).toISOString();
    const normalized = Object.assign({}, obj);
    // common possible field names mapping
    if (!normalized.indicator) {
      normalized.indicator = normalized.ip || normalized.indicator_value || normalized.id || normalized.indicator_id || "";
    }
    if (!normalized.indicator_type) {
      // infer from indicator
      if (/^\d{1,3}(\.\d{1,3}){3}$/.test(normalized.indicator)) normalized.indicator_type = "ipv4-addr";
      else if (normalized.indicator.includes('/')) normalized.indicator_type = "ipv4-net";
      else if (normalized.indicator.includes('@')) normalized.indicator_type = "email-addr";
      else normalized.indicator_type = normalized.type || normalized.indicator_type || "unknown";
    }
    normalized.first_seen = normalized.first_seen || normalized.created || normalized.first || now;
    normalized.last_seen = normalized.last_seen || normalized.modified || normalized.last || normalized.first_seen || now;
    normalized.source = normalized.source || (normalized.raw && normalized.raw.source) || "unknown";
    normalized.confidence = normalized.confidence || normalized.abuseConfidenceScore || normalized.confidence || "medium";
    normalized.references = normalized.references || normalized.refs || [];
    return normalized;
  }

  // aggregations
  function computeStats(all){
    const countsBySource = {};
    const countsByType = {};
    const indicatorFreq = {};
    const timeline = {}; // date -> count
    const uniqueSet = new Set();

    for (const r of all){
      const rec = ensureNormalized(r);
      // record final normalized object to store
      mergedRaw.push(rec);

      const s = (rec.source||'unknown').toLowerCase();
      countsBySource[s] = (countsBySource[s]||0)+1;

      const t = (rec.indicator_type||'unknown').toLowerCase();
      countsByType[t] = (countsByType[t]||0)+1;

      const ind = rec.indicator || '';
      if (ind) {
        indicatorFreq[ind] = (indicatorFreq[ind]||0)+1;
        uniqueSet.add(ind);
      }

      const dkey = toDateKey(rec.first_seen) || toDateKey(rec.last_seen) || toDateKey(new Date());
      if (dkey) timeline[dkey] = (timeline[dkey]||0)+1;
    }

    return {countsBySource, countsByType, indicatorFreq, timeline, uniqueCount: uniqueSet.size};
  }

  // render helpers
  function renderList(container, obj, max=10){
    container.innerHTML = "";
    const entries = Object.entries(obj).sort((a,b)=>b[1]-a[1]);
    for (const [k,v] of entries.slice(0,max)){
      const row = document.createElement('div');
      row.style.display = 'flex';
      row.style.justifyContent = 'space-between';
      row.style.margin = '6px 0';
      row.innerHTML = `<div class="badge">${k}</div><div style="font-weight:700">${v}</div>`;
      container.appendChild(row);
    }
  }

  function drawBarChart(container, obj){
    // simple horizontal bars using SVG
    container.innerHTML = "";
    const entries = Object.entries(obj).sort((a,b)=>b[1]-a[1]).slice(0,8);
    const w = container.clientWidth || 360;
    const h = Math.max(80, entries.length*20);
    const svgNS = "http://www.w3.org/2000/svg";
    const svg = document.createElementNS(svgNS,'svg');
    svg.setAttribute('width','100%');
    svg.setAttribute('height',h);
    const max = entries.length ? Math.max(...entries.map(e=>e[1])) : 1;
    let y=6;
    for (const [k,v] of entries){
      const barW = Math.round((v/max) * (w-160));
      const rect = document.createElementNS(svgNS,'rect');
      rect.setAttribute('x',140);
      rect.setAttribute('y',y);
      rect.setAttribute('width',barW);
      rect.setAttribute('height',14);
      rect.setAttribute('rx',6);
      rect.setAttribute('fill','rgba(96,165,250,0.9)');
      svg.appendChild(rect);

      const label = document.createElementNS(svgNS,'text');
      label.setAttribute('x',8);
      label.setAttribute('y',y+11);
      label.setAttribute('fill','#cfe6ff');
      label.setAttribute('font-size','12');
      label.textContent = k;
      svg.appendChild(label);

      const val = document.createElementNS(svgNS,'text');
      val.setAttribute('x',140+barW+8);
      val.setAttribute('y',y+11);
      val.setAttribute('fill','#cfe6ff');
      val.setAttribute('font-size','12');
      val.textContent = v;
      svg.appendChild(val);

      y += 22;
    }
    container.appendChild(svg);
  }

  function drawTimeline(container, timelineObj){
    container.innerHTML = "";
    const entries = Object.entries(timelineObj).sort((a,b)=>a[0].localeCompare(b[0]));
    if (!entries.length){
      container.innerHTML = '<div class="small">No timeline data</div>';
      return;
    }
    // build arrays
    const labels = entries.map(e=>e[0]);
    const values = entries.map(e=>e[1]);
    const max = Math.max(...values);
    const svgNS = "http://www.w3.org/2000/svg";
    const w = container.clientWidth || 800;
    const h = container.clientHeight || 120;
    const pad = 28;
    const svg = document.createElementNS(svgNS,'svg');
    svg.setAttribute('width','100%'); svg.setAttribute('height',h);

    // draw baseline
    const stepX = (w-2*pad) / Math.max(1, labels.length-1);
    // polyline points
    let points = [];
    for (let i=0;i<labels.length;i++){
      const x = pad + i*stepX;
      const y = pad + ( (h-2*pad) * (1 - (values[i]/max)) );
      points.push(`${x},${y}`);
      // x labels
      const t = document.createElementNS(svgNS,'text');
      t.setAttribute('x',x);
      t.setAttribute('y',h-6);
      t.setAttribute('font-size','10');
      t.setAttribute('fill','#9fbff0');
      t.setAttribute('text-anchor','middle');
      t.textContent = labels[i];
      svg.appendChild(t);
    }
    // polyline
    const poly = document.createElementNS(svgNS,'polyline');
    poly.setAttribute('points', points.join(' '));
    poly.setAttribute('fill','none');
    poly.setAttribute('stroke','rgba(96,165,250,0.9)');
    poly.setAttribute('stroke-width','2');
    svg.appendChild(poly);
    // area fill (light)
    const area = document.createElementNS(svgNS,'polygon');
    area.setAttribute('points', `${points.join(' ')} ${pad+h*0.01},${h-pad} ${pad},${h-pad}`);
    area.setAttribute('fill','rgba(96,165,250,0.06)');
    svg.appendChild(area);
    // values (small circles)
    for (let i=0;i<labels.length;i++){
      const x = pad + i*stepX;
      const y = pad + ( (h-2*pad) * (1 - (values[i]/max)) );
      const c = document.createElementNS(svgNS,'circle');
      c.setAttribute('cx',x); c.setAttribute('cy',y); c.setAttribute('r','3');
      c.setAttribute('fill','#60a5fa'); svg.appendChild(c);
    }
    container.appendChild(svg);
    // range text
    timelineRange.textContent = `${labels[0]} → ${labels[labels.length-1]} (${labels.length} day(s))`;
  }

  function updateUI(agg){
    totalCountEl.textContent = records.length;
    statTotal.textContent = records.length;
    uniqueIndicators.textContent = agg.uniqueCount;
    // lists + charts
    renderList(sourceList, agg.countsBySource, 10);
    renderList(typeList, agg.countsByType, 10);
    drawBarChart(sourceChart, agg.countsBySource);
    drawBarChart(typeChart, agg.countsByType);

    // top indicators
    const items = Object.entries(agg.indicatorFreq).sort((a,b)=>b[1]-a[1]).slice(0,25);
    topIndicators.innerHTML = "";
    for (const [ind,count] of items){
      const node = document.createElement('div');
      node.style.display='flex'; node.style.justifyContent='space-between'; node.style.padding='6px 0'; node.style.borderBottom='1px solid rgba(255,255,255,0.02)';
      node.innerHTML = `<div style="font-family:monospace">${ind}</div><div style="font-weight:700">${count}</div>`;
      topIndicators.appendChild(node);
    }
    drawTimeline(timelineChart, agg.timeline);
    renderTable();
  }

  // Table rendering with paging and filtering
  function renderTable(){
    const filter = filterText.value.trim().toLowerCase();
    const filtered = records.filter(r=>{
      const s = (r.indicator||'') + ' ' + (r.indicator_type||'') + ' ' + (r.source||'');
      return !filter || s.toLowerCase().includes(filter.toLowerCase());
    });
    pageSize = parseInt(pageSizeSelect.value,10);
    const totalPages = Math.max(1, Math.ceil(filtered.length / pageSize));
    pageIndex = Math.min(pageIndex, totalPages);
    const start = (pageIndex-1)*pageSize;
    const pageSlice = filtered.slice(start, start + pageSize);

    tableBody.innerHTML = "";
    for (const rec of pageSlice){
      const tr = document.createElement('tr');
      tr.style.cursor = 'pointer';
      tr.addEventListener('click', ()=> {
        navigator.clipboard.writeText(JSON.stringify(rec, null, 2)).then(()=> {
          alert('Copied record JSON to clipboard');
        });
      });
      tr.innerHTML = `<td style="font-family:monospace">${rec.indicator||''}</td>
                      <td>${rec.indicator_type||''}</td>
                      <td>${(rec.first_seen||'')}</td>
                      <td>${(rec.last_seen||'')}</td>
                      <td>${(rec.source||'')}</td>
                      <td>${(rec.confidence||'')}</td>`;
      tableBody.appendChild(tr);
    }
    pageIndexEl.textContent = pageIndex;
    pageTotalEl.textContent = totalPages;
  }

  // high-level file handling
  function handleFiles(files){
    const readers = [];
    mergedRaw = [];
    records = [];
    if (!files || files.length === 0) return;
    const promises = Array.from(files).map(file => {
      return new Promise((resolve) => {
        const fr = new FileReader();
        fr.onload = (ev) => {
          const text = ev.target.result;
          const parsed = parseJSONL(text);
          resolve(parsed);
        };
        fr.onerror = () => resolve([]);
        fr.readAsText(file);
      });
    });

    Promise.all(promises).then(results => {
      // flatten
      const all = results.flat();
      // ensure normalized objects for UI and downstream
      records = all.map(ensureNormalized);
      // compute aggregates
      mergedRaw = [];
      const agg = computeStats(records);
      // NOTE computeStats pushes recs to mergedRaw; but we want mergedRaw to contain normalized records.
      // computeStats called above used records already normalized in ensureNormalized map, but computeStats re-normalizes.
      // To be safe, regenerate mergedRaw as normalized records:
      mergedRaw = records.map(r=>r);
      updateUI(agg);
    });
  }

  // drag & drop events
  const dropzone = document.getElementById('dropzone');
  dropzone.addEventListener('dragover', e => { e.preventDefault(); dropzone.style.borderColor = 'rgba(96,165,250,0.9)'; });
  dropzone.addEventListener('dragleave', e => { dropzone.style.borderColor = ''; });
  dropzone.addEventListener('drop', e => {
    e.preventDefault(); dropzone.style.borderColor = '';
    const dt = e.dataTransfer;
    handleFiles(dt.files);
  });

  // file input
  document.getElementById('fileInput').addEventListener('change', (ev)=>{
    handleFiles(ev.target.files);
  });

  // export merged JSONL
  document.getElementById('exportBtn').addEventListener('click', ()=>{
    if (!mergedRaw || mergedRaw.length === 0){ alert('No records to export'); return; }
    const lines = mergedRaw.map(r => JSON.stringify(r));
    const blob = new Blob([lines.join('\\n')], {type: 'application/json'});
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    const stamp = new Date().toISOString().slice(0,10);
    a.download = `merged_${stamp}.stix.jsonl`;
    a.click();
    URL.revokeObjectURL(url);
  });

  // clear
  document.getElementById('clearBtn').addEventListener('click', ()=>{
    if (!confirm('Clear loaded records from the dashboard?')) return;
    records = []; mergedRaw = [];
    totalCountEl.textContent = '0';
    statTotal.textContent = '0';
    uniqueIndicators.textContent = '0';
    sourceList.innerHTML = ''; typeList.innerHTML=''; topIndicators.innerHTML=''; timelineChart.innerHTML=''; sourceChart.innerHTML=''; typeChart.innerHTML=''; tableBody.innerHTML='';
  });

  // paging and filtering
  document.getElementById('prevBtn').addEventListener('click', ()=> { if (pageIndex>1){ pageIndex--; renderTable(); }});
  document.getElementById('nextBtn').addEventListener('click', ()=> { pageIndex++; renderTable(); });
  pageSizeSelect.addEventListener('change', ()=> { pageIndex = 1; renderTable(); });
  filterText.addEventListener('input', ()=> { pageIndex = 1; renderTable(); });

  // keyboard paste: accept clipboard text containing JSONL
  window.addEventListener('paste', async (e) => {
    const text = (e.clipboardData || window.clipboardData).getData('text');
    if (!text) return;
    // quick heuristic: contains \n and '{'
    if (text.includes('\\n') && text.includes('{')){
      if (!confirm('Paste detected — parse clipboard text as JSONL?')) return;
      const parsed = parseJSONL(text);
      records = parsed.map(ensureNormalized);
      mergedRaw = records.slice();
      const agg = computeStats(records);
      updateUI(agg);
    }
  });

  // on resize, redraw charts
  let resizeTimer;
  window.addEventListener('resize', ()=> {
    clearTimeout(resizeTimer);
    resizeTimer = setTimeout(()=>{
      // re-draw current charts based on last computed aggregates
      if (!mergedRaw || mergedRaw.length === 0) return;
      const agg = computeStats(records);
      updateUI(agg);
    },200);
  });

})();
</script>
</body>
</html>
